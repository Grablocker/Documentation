\documentclass[lang=cn,10pt]{elegantbook}

\title{智弈锋穹--AI驱动的攻防自治演训靶场}
\subtitle{项目文档}

\author{何树贤、易梦哲、周君赢、陈易东、张军、牟航、周望、张顾峰、黄睿哲、孙明皓}
\bioinfo{指导老师}{张立强、何艺、严飞}
\institute{武汉大学 国家网络安全学院}
\date{2025年8月14日}

% \extrainfo{不要以为抹消过去，重新来过，即可发生什么改变。—— 比企谷八幡}

\setcounter{tocdepth}{3}

% \logo{cyber-4084719_1280.jpg}
\cover{cyber-4084719_1280.jpg}


% 本文档命令
\usepackage{array}
\usepackage{hyperref}
\newcommand{\ccr}[1]{\makecell{{\color{#1}\rule{1cm}{1cm}}}}

% 修改标题页的橙色带
\definecolor{customcolor}{RGB}{7,8,8}
\colorlet{coverlinecolor}{customcolor}

\begin{document}

\maketitle
\frontmatter

\tableofcontents

\mainmatter


\chapter{项目背景和概述}
\begin{introduction}
    \item 赛题背景
    \item 基本知识背景
\end{introduction}

\section{赛题背景}

党的十八大以来，以习近平同志为核心的党中央高度重视网络安全工作，特别在目前日趋复杂
的背景下，深刻认识和有力防范网络安全风险，切实维护网络空间安全，已成为事关全局的重大课
题。

随着《网络安全法》和《国家网络空间安全战略》的深入推进，
实战化网络攻防能力的建设成为网络安全体系中的关键任务之一，
尤其在“十五五”规划对关键信息基础设施安全防护提出更高要求的背景下，
传统的网络安全演练方式已难以满足动态演训和智能对抗的发展趋势，
目前在实际操作中面临三方面的主要瓶颈：

一是传统靶场场景构建模式过于静态，往往采用人工预设的方式搭建演练环境，
更新周期长、调整代价高，导致其难以及时引入现实世界中快速变化的业务架构、
操作流程以及技术组件，也无法涵盖近年来不断涌现的新型攻击方式与复杂威胁模型，
例如APT、供应链渗透、0day漏洞利用等，
这种脱节使得演练内容始终滞后于现实威胁的发展态势，
无法为参与者提供贴近实战的演练体验，也难以检验系统和人员在面对未知攻击时的应对能力，
从而削弱了靶场演练在实战能力培养中的实际价值。

二是攻击路径往往依赖人工预设，主要根据经验规则构建固定的攻击链条，
缺乏动态生成机制与策略调整能力，导致攻击行为表现出明显的模式化特征，
不仅在路径选择上缺乏多样性，也难以模拟出真实渗透过程中攻击者面对防护机制时的适应性调整与策略转移，
无法体现现代网络攻防中攻击面广泛、路径不确定、阶段交错的复杂局面，
这种设计上的单一性和僵化性直接削弱了演练的覆盖广度与挑战强度，
最终造成演练内容与现实渗透行为之间出现严重脱节。

三是评估机制普遍依赖人工回顾，
主要通过事后分析操作日志、观察系统响应或专家打分等方式进行效果判断，
不仅耗时耗力，而且评判结果高度依赖评估人员的主观判断，
缺乏统一的标准与可复用的指标体系，难以保障结果的一致性与公正性，
也制约了后续能力提升、策略优化与人才选拔的科学性与有效性。

这些问题在一定程度上制约了演练体系的有效性和可持续发展，
因此亟需以网络攻防动态推演为核心突破口，
引入AI Agent、数据分析与自动化决策等新技术，
实现演练环境的动态演化、攻击过程的智能模拟、
防御策略的自适应优化以及评估体系的全面量化，
从根本上提升攻防演练的实效性与科学性，推动网络安全实战能力建设迈上新台阶。

\section{基本知识背景}

\subsection{KVM虚拟机}

KVM是一种内建于Linux内核的虚拟化技术，
它将Linux操作系统转变为一个完整的Type-1虚拟化管理程序。
KVM依赖硬件虚拟化扩展（如Intel VT或AMD-V）来为每个虚拟机提供
独立的虚拟CPU和内存资源，并通过QEMU作为后端模拟设备和系统行为，
从而运行不同操作系统的虚拟实例。每台虚拟机以普通进程的形式运行在宿主机上，
由内核模块kvm.ko管理其特权指令的捕获与转发。KVM虚拟机具备高性能和低开销的特点，
支持资源动态分配、快照保存、虚拟网络构建等功能，适合用于构建多租户的复杂网络环境。
通过Libvirt工具集与Virt-Manager图形界面，
用户可以以更直观和统一的方式对虚拟机生命周期进行管理，
显著简化了大规模虚拟基础设施的运维难度。

\subsection{Docker容器}

Docker是一种轻量级虚拟化技术，
它通过操作系统级别的内核功能如命名空间和控制组来实现对进程的隔离与资源限制。
容器运行在共享内核的宿主机上，但对每个容器而言，它拥有独立的文件系统、网络堆栈
与进程空间。Docker镜像作为容器的模板，以分层文件系统构建，支持快速部署与复用，
显著提升了环境一致性和服务交付效率。
相较于虚拟机，容器启动速度更快、占用资源更少，更适合部署短周期、可弹性伸缩的服务。
在靶场环境中，Docker通常用于承载Web服务、数据库、日志分析平台等高频变化的组件，
通过Docker Compose工具可实现多容器服务的集中编排，提升整体自动化部署水平。

\subsection{virsh虚拟化管理工具}
在本项目中，virsh作为底层虚拟化管理的核心引擎，为靶场环境提供一致、可重复的虚拟机与网络资源创建能力。借助Libvirt的XML描述语言，用户可以精确地定义每台虚拟机的CPU、内存、磁盘以及网络接口参数，并通过简单的命令完成虚拟机的启动、暂停、迁移和销毁操作。virsh所依赖的网络桥接与NAT功能能够为不同实验场景隔离网络流量，同时支持在运行时动态调整虚拟网络拓扑，使得在一次部署中完成多种攻防场景成为可能。通过将这些配置脚本化并纳入版本管理，全流程的环境还原、回滚与审计都可在几分钟内完成，极大地提升了演练效率与运维可控性。

\subsection{iptables转发规则}
iptables在内核空间负责对网络数据包进行精细化处理，是实现外部流量与靶场内部主机通信的关键组件。项目中首先在NAT表的PREROUTING链中完成端口映射，将来自外部的SSH、Web、VPN等请求透明地导向各自的容器或虚拟机；随后在filter表的FORWARD链中实施基于源网段、目的网段和协议端口的策略过滤，既可按照安全域对流量进行白名单放行，也能针对异常会话进行日志记录与审计。在规则定义上，我们将常用策略模板化，并结合脚本自动生成不同演练场景下的规则集，支持增量更新与快速回滚，从而在保证性能稳定的同时，实现对复杂网络拓扑的灵活管控。

\subsection{漏洞挖掘、利用与防护}
为了全面评估目标系统的安全性，项目引入漏洞挖掘到防护的闭环流程。首先通过静态代码扫描和动态漏洞扫描工具结合手工代码审计，识别出潜在的配置缺陷与已知安全漏洞；接着利用Metasploit框架或自研Exploit脚本，对关键服务和应用展开攻击演练，模拟真实攻击链路并生成详细的行为日志；最后基于安全最佳实践和攻防对抗结果，自动化地生成补丁包、访问控制策略或WAF规则，实现对已验证漏洞的快速修复与策略下发。整个过程与日志评估模块相结合，可不断校正检测手段的准确性，推动防御策略从经验驱动向数据驱动转型。

\subsection{模糊测试}
为了发现传统漏洞扫描无法覆盖的边界场景和输入验证缺陷，项目集成了基于覆盖率反馈的模糊测试框架。该框架通过自动化生成海量畸形或半结构化输入，用以测试目标应用的协议解析、接口参数和异常状态响应，并实时追踪代码执行路径和崩溃点。结合基于多轮迭代的种子输入优化策略，系统能动态调整变异算法以覆盖更多分支，显著提高漏洞触发率和测试深度。最终，将模糊测试结果与静态或动态扫描报告融合，为安全团队提供多维度的缺陷洞察，从而在未知攻击面前建立更稳健的防护屏障。


\subsection{AI Agent}

AI Agent是一种具备感知、决策与执行能力的自主体，
用于模拟人类在特定任务下的操作行为。
在攻防演练中，Agent通过持续感知环境变化、分析目标系统特征、
结合既有知识进行推理并最终发起攻击或防御行为，体现出智能化对抗的动态性和自适应性。

一个典型的Agent包括感知模块、知识表示模块、策略生成模块和行为执行模块，
其运行过程涉及对目标资产的信息采集、漏洞推理、攻击路径生成和自动化利用。
随着大模型技术的发展，Agent逐渐具备了更强的自然语言理解能力与代码生成能力，
能够从文档、漏洞数据库中抽取并构建攻击利用逻辑。

在本项目中，我们使用了Gemini CLI构建攻防Agent，借助其集成的上下文感知机制、
多模态输入解析能力和代码生成能力，完成对渗透链条的智能模拟与自动攻击脚本的生成，
探索了基于大模型驱动的Agent在靶场环境中的实战应用潜力。
另外，我们还对整体框架进行修改编辑，生成Agent log使其行为可以被追踪和审计。


\chapter{项目设计思路与方案}
\begin{introduction}
  \item 项目目标设计思路
  \item 前端设计方案
  \item 靶场基础设施设计方案
  \item 攻击模块设计方案
  \item 防御模块设计方案
  \item 评价模块设计方案
  \item 模块协同设计
\end{introduction}
\section{项目目标设计思路}
攻击防御评价系统的目标设定，
源于网络安全演练领域的核心痛点：传统演练多依赖人工搭建环境、手动记录过程，
存在场景单一、评估主观、效率低下等问题。
基于此，系统目标聚焦于构建 “全流程数字化演练平台”，
通过拓扑结构展示、AI Agent驱动的攻击演练、自动化评估三大核心功能，
实现从环境搭建到结果分析的闭环管理。

\begin{theorem}
    前后端数据实时交互，杜绝因信息延迟影响演练效果。
\end{theorem}

从功能边界来看，前端与后端的拆分遵循展示与控制分离的设计原则。
前端主要负责构建可视化的交互界面，包括资源监控平台和模拟终端，
便于用户直观了解网络运行状态和攻击演进过程，
增强了用户的操作体验和对演练环境的理解程度，
而后端则不仅承担着靶场底层拓扑结构的可调整参数的搭建与管理，
确保整个系统运行的稳定性与评估指标的客观性，
同时还集成了AI Agent自主攻击模块、防御控制模块
以及完整的演训日志记录系统，
使得整个平台具备自动化、智能化的攻防能力和可审计的追踪能力，
这种架构设计不仅有效满足了用户在操作便捷性方面的需求，
也充分保障了平台在功能性、扩展性与安全性方面的可靠性，
最终形成了一个高效、智能、可信的网络安全实战演练平台，
为防护能力的验证与提升提供了可量化、可复现、可定制的技术依据。

\begin{definition}
    明确系统旨在解决传统演练痛点：

    方案布局上，通过 “可调参数的基础设施 + AI赋能的行为演训” 破除
    传统靶场痛点难题；

    设计架构上，通过 “前端展示 + 后端控制” 架构实现
    全流程数字化可视化闭环管理。
\end{definition}

\section{前端部分设计方案}
前端设计的核心矛盾在于 “动态场景多样性” 与 “前端展示架构稳定性” 的平衡。
为解决这一矛盾，方案采用 “大模型生成 + 预设框架约束” 的混合模式，
既发挥大模型在动态内容生成上的优势，又通过框架控制不确定性。


在内容生成层面，选择大模型的核心原因是应对复杂网络场景的多样性需求。
网络拓扑、攻击路径等展示内容需根据用户输入的业务场景动态调整，
大模型可基于预设规则生成符合逻辑的可视化元素，大幅降低手动绘制的成本。
但大模型生成存在随机性，因此引入预设框架作为约束 —— 基于 Vue  构建组件库，
包含拓扑图组件、攻击流程日志、LLM评估结果展示等标准化模块，
确保生成内容在布局、交互逻辑上的一致性。

交互设计上，输入框则支持自定义需求，
如 “添加自定义业务系统图标”“修改拓扑连线样式” 等，满足个性化场景。
同时，界面美观性通过 “分层视觉设计” 实现：底层为网络拓扑基础图层，
中层为攻击 / 防御动态效果层，顶层为操作交互层，配合蓝白主色调，确保运维与安全人员能快速捕捉关键信息。

\begin{definition}
    前端通过 “大模型 + 预设框架” 平衡动态性与稳定性，交互设计兼顾易用性与个性化，
    视觉分层提升信息获取效率。
\end{definition}

\section{靶场基础设施设计方案}

\subsection{混合式靶场构建架构}

为精确模拟现实企业网络中的复杂性和层次性，我们采用虚拟机（VM）与容器（Docker）混合构建的方式，搭建出具备多网段分区、可控攻防流程的综合性靶场环境。这种混合式架构在单一Linux宿主机上部署，结合KVM虚拟化技术与Docker容器技术的优势，兼顾资源利用率、部署灵活性与网络隔离性，特别适用于网络安全研究与攻防演练场景。

具体来说，KVM提供完整的系统虚拟化能力，适合部署如办公终端、数据库服务器、安全监控平台等需要独立操作系统环境的资产；其高度的隔离性有助于精确控制不同主机间的攻击面暴露。Docker容器则主要用于部署Web服务、邮件服务、VPN节点、日志收集器等应用层服务，其部署迅速、资源占用小，便于模拟海量业务服务的动态上线与下线过程。

整个靶场通过宿主机iptables规则和NAT配置进行网络调度和访问控制，不同虚拟资产被划分至逻辑隔离的子网中（如外部网络、DMZ区、内部网、管理网等），通过有序的访问链条构建典型攻击路径，为自动化攻击链生成与防御部署策略验证提供实验平台。该架构既能保障底层网络和系统级别的真实还原，又能支持快速迭代的攻防实验，兼顾研究深度与开发效率。


\subsection{libvirt 与 virsh结合的管理机制}

为了有效管理靶场中众多KVM虚拟机资源，我们引入libvirt虚拟化抽象层及其命令行接口工具 \texttt{virsh} 进行集中控制与自动化操作。libvirt 提供统一的 API 和后端支持，允许用户在多种虚拟化平台（如KVM、QEMU）上以一致的方式创建、配置、运行与监控虚拟机资源。

virsh 是 libvirt 提供的核心命令行管理工具，具备如下功能：

\begin{itemize}
  \item 创建、导入与删除虚拟机定义（通过XML配置或克隆方式）
  \item 实时启动、关闭、挂起与恢复虚拟机状态
  \item 配置虚拟网络、网桥、磁盘挂载等底层资源
  \item 监控虚拟机运行状态与资源消耗
\end{itemize}

通过 libvirt 虚拟网络功能，我们可以为不同虚拟机分配逻辑子网，配置独立网桥或NAT模式网络，并与宿主机iptables规则配合，实现复杂的内部通信结构与访问边界控制。例如，可为 net-ext、net-dmz、net-int 等网络区域分别定义独立虚拟网络，并将其绑定至不同的KVM VM。

此外，libvirt 还支持使用 XML 文件模板进行大规模虚拟机的自动部署与配置，使得整个靶场环境具备良好的可复现性与脚本化能力，便于后续的版本迭代与实验重构。

综上，通过 libvirt + virsh 的管理机制，我们不仅实现了对虚拟机资源的集中调度，还为混合靶场的生命周期管理提供了强有力的底层支撑。

\subsection{KVM虚拟网络配置}

在本靶场平台中，虚拟网络被设计为与企业典型分区一致的四个逻辑区域：外部网络、隔离区（DMZ）、内部业务网和管理网。每个区域在宿主机上对应一条 Linux Bridge，并由 libvirt 进行统一生命周期管理。宿主机的物理网卡直接接入外部网络桥，其余网络桥保持纯虚拟化，以便通过 iptables 或 nftables 精细控制跨区访问。

外部网络桥主要用于模拟互联网流量，为靶场提供真实的出入口；DMZ 区承载对外服务，如 Web 前端或跳板机，是攻击者进入内部之前的缓冲带；内部业务网聚合数据库、文件服务等核心资产，默认与外界隔离；管理网专供日志收集、监控与自动化运维流量，通过独立的地址段与更严格的策略实现最小暴露面。

在虚拟机层面，每台 KVM 实例根据角色被分配一张或多张网卡，分别连接到对应网络桥。这样既能还原多网卡设备（如堡垒机或防火墙）的真实部署，也能在同一宿主机内部构建完整的东西向与南北向流量路径。若需进一步细分租户或场景，可在桥上叠加 VLAN 或通过 VXLAN 隧道把同一网段扩展到多台宿主机。

配合 virtio-net 与 vhost-net 加速，以及统一 MTU 和流量整形策略，靶场网络既保证了高性能转发，又能通过包过滤和速率限制将潜在的恶意流量控制在预期范围内。这样的网络拓扑为后续攻击链编排、流量回放和安全策略验证提供了稳定、灵活且接近真实生产环境的基础设施。



\begin{proposition}[关于自动化设置的几点说明]

为了实现场景的自动生成和参数的实时调整，
我们在靶场控制面中引入一套轻量级 Agent 作为核心调度器。
所有虚拟机与容器均以预构建镜像形式存放于本地仓库，启动时仅需加载模板即可完成系统级配置；
而业务层面的变更（如服务端口、日志路径）则通过一份声明式 XML 文件描述。
Agent 负责解析该文件，为每台实例分配不冲突的子网地址、
更新 virsh 或 Docker 网络映射和网段分配，
并基于场景标签自动生成对应的 \textit{iptables} 规则集。

在运行过程中，Agent 持续订阅宿主机资源指标与攻击事件流。
当检测到资源瓶颈或攻击阶段变更时，它会实时调整 CPU 内存配额、动态收缩或扩展网络带宽，
并对现有防火墙策略进行增删改，确保实验流量始终处于可控范围。
所有调整操作均通过热更新接口完成，无需停止虚拟机或容器即可生效，
从而实现靶场环境的秒级重塑与精细化调优。
\end{proposition}

\section{攻击模块设计方案}

\subsection{关键场景攻击链构建}

攻击模块设计以模拟真实网络环境中的典型高级持续性威胁为目标，
打勾选取基础场景，通过构建完整的攻击链路，
展示从初始渗透到数据窃取的全过程。在渗透阶段，
AI Agent将尝试执行社会工程攻击或已知漏洞利用以获取初始访问权限；
在横向移动阶段，攻击体主动识别内网结构，渗透并控制更多节点，
扩大攻击面；在数据窃取阶段，模拟攻击者对已入侵主机进行文件扫描与关键数据提取，
目标文件人工预设于用户目录下，以增强演练的真实性与针对性。
整个过程由攻击AI Agent主导执行，路径选择具备自主决策能力，
可根据目标系统环境自动调整策略，反映出复杂攻击链在真实场景中的演化过程。

\subsection{人工辅助漏洞利用与EXP构建流程}

除自动化攻击路径外，系统也支持人工参与的漏洞利用流程，
用于检验攻击分析能力与EXP生成能力。在内核层面，
演练人员可选择已知存在或根据实际生产环境构建的高危漏洞的虚拟机镜像。

对于nday漏洞演练：
通过调试与运行验证EXP的有效性；在Web服务层面，结合xray和nuclei等漏洞扫描工具，
对目标站点进行扫描与信息收集，识别存在的安全隐患，
并在社区或数据库中查找已公开的PoC，修改参数以适配当前演练环境，
从而实现漏洞的成功利用。整个过程强调人工分析能力与漏洞利用链构建能力的锻炼，
辅助AI Agent形成更完善的攻击库资源。

对于0day漏洞以及APT攻击演练：

\subsection{攻击Agent的自动化执行机制}
我们使用开源Agent客户端框架Gemini Cli作为我们的AI Agent基本架构，
该框架支持多种主流操作系统（如 Windows、Linux、MacOS等），也可适配OpenEuler等国产开源系统。
可配置工作目录自主设置RAG，
并能操作终端执行命令，并自反馈的给出相应回答和调整

为了实现攻击行为的自主执行，攻击Agent具备版本识别、漏洞关联与自动配置功能。
在目标识别阶段，Agent基于资产信息与系统指纹确定目标组件与版本号，
在项目构建的Agent RAG知识检索系统中查找与之对应的已知漏洞信息，并获取匹配的PoC样本；
在利用准备阶段，Agent自动对PoC进行重构与配置，
主要完成攻击目标的地址替换、参数填充与脚本适配；最终执行攻击操作，
并使用Agent log监控其效果反馈，包括系统响应、异常状态与返回值，判断攻击是否成功，
并在必要时根据失败原因调整路径或切换攻击手段，实现攻击链的持续推进与策略自适应。

\subsection{攻击行为自动化评估与结果统计}

为支持攻击模块的自动化评估机制，我们在Agent的架构中设计了基于日志驱动的攻击效果量化方案，
攻击Agent在每次执行攻击任务时将自动记录完整的行为的shell执行日志，
在这些日志中，信息包括攻击起始时间、攻击方法、所用EXP等。

然后，系统使用量化模型以及LLM对这些数据进行自动归类与统计，生成攻击尝试与成功次数的对比结果，
并以可视化方式呈现给用户，辅助评估攻击路径的有效性、
Agent策略的合理性以及环境部署的防护能力，
从而实现攻击行为从执行到评估的全流程自动、闭环管理。


\section{防御模块设计方案}
防御模块以 “精准识别 + 高效响应” 为目标，通过 “日志审计 + AI 检测 + 独立分析” 的三层架构，
实现对攻击行为的全链路感知与评估。

日志审计层负责数据采集，覆盖容器日志（如 K8s 事件日志）、网络流量日志（如防火墙规则命中记录）
、应用日志（如 Web 服务器访问日志）等全维度信息。
采用 ELK（Elasticsearch+Logstash+Kibana）栈进行日志聚合，
通过 Filebeat 代理实时采集日志，经 Logstash 清洗（如过滤冗余字段、标准化时间格式）
后存入 Elasticsearch，确保数据的完整性与一致性。

AI 检测层是防御核心，采用 “特征工程 + 深度学习” 混合模型。
特征工程提取攻击行为的静态特征（如异常端口访问、恶意 User-Agent）
；深度学习模型（如 LSTM 神经网络）则通过训练历史攻击日志，
学习动态攻击模式（如 SQL 注入的字符变异规律、勒索病毒的文件加密行为序列）。
模型部署采用 TensorFlow Serving 容器化方案，支持实时接收日志数据并输出攻击概率评分（0-100 分），评分超过阈值（如 70 分）则触发告警。

为提升检测准确性，设计独立日志分析模块。该模块采用微服务架构，与攻击、防御其他模块完全解耦，通过消息队列（如 Kafka）异步接收日志数据，避免资源竞争与干扰。同时，模块内置 “误报修正机制”—— 当 AI 检测到攻击行为后，自动关联历史日志中的正常操作记录进行交叉验证，例如，某 IP 触发 “异常登录” 告警时，若该 IP 在过去 30 天有多次正常登录记录且属于企业内网段，则降低告警等级，减少误报率。

\begin{proposition}
（防御模块可能缺乏的说明）
\end{proposition}



\section{评价模块设计方案}

评价模块旨在通过对攻击机 Shell 行为日志的深度分析，为整体防御体系提供精准、可落地的改进建议。
首先，模块会持续采集 Agent 在目标机器上记录的所有交互式命令和系统调用等关键日志，
通过统一的预处理管道清洗、聚合出高效特征向量，并将其按照语义和行为模式分批次推送至大规模语言模型（LLM）中，
以便对潜在威胁行为进行上下文理解与行为溯源。整个过程采用流式数据传输与异步调度相结合的方式，
既保障了日志传输的实时性，又在保证系统吞吐的同时防止了过载风险。

在日志解析阶段，评价模块依托 LLM 强大的自然语言理解与推理能力，
针对命令执行先后顺序、参数使用逻辑以及与已知攻击场景的相似度等维度，生成多维度行为画像，
并对可能存在误报、漏报或策略盲区的环节进行重点标注。随后，模块结合内置的评分模型与安全最佳实践库，
对每一次攻击尝试给出可量化的安全得分，通过连续监测得分变化来评估防御策略的有效性。同时，
为了使反馈更具可操作性，评价模块以“风险描述 + 改进建议 + 优先级指引”的形式输出详细报告，
帮助安全运维团队从策略调整、权限收敛和审计日志配置等多个层面迅速响应。

为了实现持续优化，评价模块内置自我学习机制。每次运维人员对报告中建议的采纳情况和后续安全事件的响应结果，
都会被回馈至评估引擎，用于修正后续行为分析的权重分配与建议生成逻辑。在实践中，随着样本累积和模型微调，
评价模块将不断提升对新型威胁模式的识别能力，进一步缩短从发现异常到落地防御的周期，真正做到“检测—评估—响应—复盘”的闭环迭代。



\section{模块协同设计}
各模块并非独立运行，而是通过数据流转形成闭环：前端将用户配置（如演练场景参数）传递给后端；后端根据参数部署容器环境、生成网络拓扑，并将环境信息同步至攻击模块；攻击模块完成漏洞扫描与攻击演示后，将攻击过程数据（如时间、路径、结果）推送至防御模块；防御模块的日志分析与 AI 检测结果，经后端自动化评估引擎处理后，转化为可视化图表在前端展示。这种协同机制确保了 “环境 - 攻击 - 防御 - 评估” 全流程的连贯性，最终实现系统的核心价值 —— 为网络安全防护提供可信赖的演练与评估平台。
\begin{definition}
    各模块通过数据闭环协同，实现从场景配置到评估展示的全流程贯通，保障系统功能的完整性与连贯性。
\end{definition}




\chapter{方案实现}
\begin{introduction}
  \item 靶场环境构建及其自动化、参数调整
  \item 攻击模块设计方案
  \item 防御模块设计方案
  \item 评估模块设计方案
\end{introduction}

\section{靶场环境构建方案及其自动化、参数调整}

靶场网络的三层架构由主机层、网段层和转发层按功能职责依次递进构成，既保证了环境搭建的可复用性，
也为后续的自动化和参数化调整提供了清晰的模块化边界。

\subsection{主机层}
主机层以虚拟化实例与容器化服务共同构成靶场的算力基础。
通过在宿主机上并行部署若干虚拟机实例，同时在指定的 VM 中运行 Docker 容器群，实现对攻防目标的多样化呈现。
为了打通内外网访问，主机层还集成了一台基于 OpenVPN 的跳板机，该节点既作为运维管理的入口，
也承担了虚拟网关的职责。所有靶场主机通过桥接或路由方式与跳板机互联，形成了可控的逻辑拓扑，
同时在该层面预留了 Agent 工作目录，用于后续收集日志、下发配置及执行自动化脚本。

\subsection{网段层}
网段层借助 XML 模板化定义虚拟网络的逻辑结构，按照管理网、外网、DMZ 区和内网等安全域划分多个子网。
通过 Libvirt 提供的网络描述语法，手动编写或由 LLM Agent 生成网络段配置文件，然后使用“virsh net-define”完成初始注册，
再经由“virsh net-start”激活各网段。该流程可将网段划分、网关地址规划及 DHCP 参数一并注入，
形成一组可自动化复用的网络定义。Agent 在工作目录中保留若干 Few-Shot 模板，负责动态填充网段名称、
网关 IP 与 CIDR 范围，从而实现基于场景的网络拓扑快速构建。

\subsection{转发层}
转发层依托 iptables 在宿主机内核空间实施精细化的报文转发与策略控制。
首先在 NAT 表的 PREROUTING 链中完成端口和地址的 DNAT 映射，使外部请求可透明访问内网 VM 或容器；
接着在 filter 表的 FORWARD 链中，通过策略链条对不同网段间的流量进行放行或丢弃。
整个规则集同样通过 Agent 调用预置模板生成脚本文件，支持对协议、端口、源/目的网段的多维度筛选，
并以异步批量下发方式加载到系统中。当需要增量调整或扩展拓扑时，只需更新少量模板参数，
Agent 即可在数秒内完成新规则的下发与生效。

这一三层架构设计将计算资源、网络拓扑与策略控制有机分离，配合 LLM Agent 的模板化与 Few-Shot 能力，
不仅极大提升了环境搭建的效率，也为后续的持续集成、动态演练和安全评估奠定了坚实基础。

% 

\subsection{动态场景生成和参数调整机制}

本靶场将网络拓扑、IP 规划与防火墙策略抽象为声明式场景描述，所有配置均由 LLM 驱动的 Agent 自动生成。流程如下：  
首先，运维人员编写包含“网段定义、桥接名称、地址池、策略语句”四大部分的 XML 模板；  
Agent 接收模板后，调用内置的语义解析模块将“允许 DMZ→内网数据库”“外网至 Web 只开 80/443”等自然语言规则转译为网段配置块和 iptables 语句；  
随后通过 libvirt API 和 Docker API 分别下发网络定义（XML/CLI）、创建对应 Linux Bridge 以及 MacVLAN 接口；最后注入生成的防火墙规则至宿主机的 nftables/iptables 中。  
整个过程无需人工编写脚本，也不需手动维护 XML 或规则文件。

在拓扑变更或安全策略更新时，只需修改 XML 中的场景描述，Agent 即可对比差异并在线更新网络配置：  
\begin{itemize}
  \item 如果新增子网或租户，自动生成对应桥接和 VLAN 接口，并在 XML 中同步标注；  
  \item 如果调整访问策略，Agent 通过热重载方式追加、删除或替换现有规则，无需中断任何虚拟机或容器；  
  \item 对于网段 IP 池扩容或收缩，Agent 调用 IPAM 子模块实时调整地址范围，并下发新的 DHCP/DNS 配置。  
\end{itemize}

由此，网络拓扑与防火墙策略的“场景—定义—执行”闭环得以在数秒内完成，可在演练过程中任意切换或重构，保证了环境的高度一致性与可控性。

\subsection{架构及部署可扩展性}

尽管当前部署集中在单节点，但设计上具有多层次的扩展能力：

\begin{enumerate}
  \item 模板复用与多实例复制  
        所有  模板支持参数化占位符，可通过批量渲染生成 N 份场景定义，Agent 可并发在多宿主或多命名空间中同步部署。  
  \item 插件化网络驱动  
        Agent 核心分为「解析」「IPAM」「桥接」「策略」四大插件，未来可替换为 Kubernetes CNI、SDN 控制器或公有云网络模块，只需编写对应适配层即可接入原有流程。  
  \item 跨宿主 VXLAN/EVPN 扩展  
        当需要跨机房或多宿主机协同时，Agent 可在现有 Linux Bridge 基础上生成 VXLAN 隧道或 EVPN 配置，并自动在 XML 中注入对等节点列表，实现 L2 网络透明延伸。  
  \item 混合云对接  
        Agent 支持将同一套场景模板渲染为 Terraform HCL 或云厂商网络定义，通过 API 在公有云中创建 VPC、子网与安全组，再使用 IPSec 或 WireGuard 将云端网络与本地长时互联。  
\end{enumerate}

上述扩展策略既保留了模板化和声明式的高层管理方式，又可无缝接入新技术栈与云平台，确保靶场环境可随需求增长而弹性伸缩。


\section{攻击模块设计方案}
\subsection{架构概述}
本攻击模块基于开源的 Gemini CLI Agent 框架，在原有流程之上引入多项扩展，以满足智能化攻击模拟需求。核心组件包括：攻击决策引擎、漏洞与利用库接口、攻击执行器以及行为日志模块。Agent 在初始化时加载各功能插件，形成从“策略决策→漏洞检索→利用执行→结果反馈”的闭环。

\subsection{对常规漏洞的复现及演练}

在常规漏洞演练中，Agent 首先对目标服务进行指纹识别，
并将服务版本信息与本地集成的 ExploitDB、Metasploit 模块库进行匹配检索。
匹配结果按风险评分和可用性排序后，Agent 自动下载或调用对应的 EXP 脚本，
生成针对目标的攻击任务。攻击执行器以并发或顺序方式发起利用请求，
并通过内置的会话管理模块检测是否成功获取 Shell 或触发漏洞行为。一个典型的靶场漏洞复现的流程如下：

首先，Agent 根据 XML 中定义的“漏洞扫描范围”加载指纹模块（如 Nmap 脚本或 HTTP banners）；  
然后Agent启用我们内置在Agent工作目录中的漏洞检索子系统进行关键字查找，查询本地数据库并返回可用 EXP 列表；  
随后攻击执行器调用 EXP，自动填充必要参数（目标 IP、端口、URL 路径、用户名/密码等），并在成功或失败后记录结果；  
复现结果与原始 EXP 元信息（CVE 编号、漏洞描述、利用条件）一并写入Shell行为日志，供后续分析与复测使用。

通过这种自动化流程，常规漏洞的复现和演练可在分钟级完成，不仅验证了漏洞利用链的完整性，也为评测团队提供了详尽的操作记录。

\subsection{模糊测试挖掘和异常检测}

针对零日或未知漏洞，我们在 Agent 中集成了多种 Fuzzing 插件，包括协议模糊、文件格式模糊和 API 参数模糊。Agent 在演练开始时，基于资产清单自动选择合适的 Fuzzer，并生成变异输入流发往目标服务。实时监控模块通过 eBPF 或动态插桩技术捕获目标进程的崩溃信息、异常日志和内存访问违规。典型流程如下：

Agent 读取“模糊测试配置”，确定测试模式（长度变异、格式变异或序列化变异）；  
Fuzzing 引擎并行输出多路变异样本，按优先级向目标发起请求，并通过覆盖率反馈调整变异策略；  
监控组件捕捉进程崩溃栈信息和异常日志，将可复现的崩溃用例存储到本地目录；  
最后 Agent 将发现的异常输入与上下文环境（目标版本、触发条件）自动归档，并将可能的利用点标注到场景描述中，供后续漏洞利用模块调用。

该机制能够在演练过程中主动挖掘潜在缺陷，并实时生成可复现测试用例，显著提升零日漏洞发现效率与准确性。


\section{防御模块设计方案}

\section{评估模块设计方案}

\subsection{Agent 行为捕获与日志生成}
在本方案中，我们对开源 Gemini CLI 进行了深度定制，使其在每次调用 shell 执行分支时能够自动生成结构化日志。
具体而言，针对 TypeScript 代码中通过 childprocess.exec 或等效方法发起的命令执行操作，注入了统一的日志入口log entry；
该入口以预定义的 JSON 模板为蓝本，记录命令字符串、执行时间戳、工作目录、用户标识以及执行结果
（包括成功、失败、回滚等状态）。在命令执行前后以及异常撤销阶段，都会分别写入对应状态的日志条目，
确保整个执行过程中的每一个关键节点都被原子化捕获。
日志层面采用异步写入策略，兼顾了性能开销最小化与日志完整性的双重需求。

\subsection{日志结构解析与图示说明}
生成的原始日志条目严格遵循统一字段规范，每条记录包含 id, timestamp, command, status
等维度属性。为便于文档说明，我们在此插入系统生成的示例图（见图），直观展现了单条日志条目的核心字段与层级关系。
该图示不仅阐释了日志中各属性的含义，也帮助读者快速理解在多状态分支下，系统如何保持对每一次命令执行全链路的端到端可追溯。

\subsection{JSON 化处理与前端交付}
日志生成完成后，通过管道化处理模块将离散的日志条目汇总为符合前端接口规范的 JSON 数据包。
该处理流程包括按时间窗口聚合、字段类型校验和可选的敏感信息脱敏，最终输出的 JSON 对象结构清晰，
便于前端组件在可视化大屏中快速渲染行为流。前端在接收到该数据后，可基于内置的时间轴控件或折线图组件，
动态展示 Agent 在靶场中执行的每一步操作，并结合评估模块提供的安全得分，实现从日志解析到可视化反馈的全流程闭环。



\chapter{效果演示}



\chapter{创新与特色}
\begin{introduction}
  \item 三层架构与网络参数动态调整
  \item 基于 Gemini CLI 的行为日志与决策引擎
  \item 攻防决策与评估一体化
  \item 前端可视化与虚拟终端实时交互
\end{introduction}

\section{三层架构与网络参数动态调整}  
本项目率先提出将主机层、网段层与转发层三者进行有机划分与协同管理的设计思路。
主机层以虚拟机和容器的混合部署为基础，为每一次攻防演练提供独立隔离的计算单元；网段层通过模板化的 XML 定义，
精准刻画各安全域的 CIDR 分片及网关属性；转发层则借助 iptables 完成从外部到内网的 DNAT、以及跨域流量的细粒度策略控制。
更为突出的是，在网段层与转发层中，我们引入了基于 LLM 的 Agent 自动化配置能力。
Agent 可根据演练场景动态生成或更新虚拟网络定义和防火墙规则，实现随时增删虚拟网段、调整网关 IP、修改转发端口等操作。
这种方案打破了传统脚本执行僵化、手工维护成本高的局限，使得网络参数的微调与拓扑重构能够在运行期在线完成，
显著缩短了环境重建与测试准备的周期，同时保持了高可用与高隔离的双重目标。

\section{基于 Gemini CLI 的行为日志与决策引擎}  
我们对开源 Gemini CLI 进行了深入改造，将其打造成既能下发指令又能实时采集 Agent 行为的智能中枢。
在每次通过 TypeScript 原生方法触发 shell 执行时代码中嵌入统一日志出口，
按预定义 JSON 模板记录命令内容、执行时长、终端输出、错误信息、退出状态等全链路数据。
所有日志条目采用异步写入与批量推送相结合的方式，既保证了对大规模并发命令的支持，也避免了性能瓶颈
。日志数据上报后，Agent 可在多轮交互中对历史行为进行回溯，并在 LLM 的推理能力加持下自主优化下一步攻击路径。
该机制不仅能全面揭示靶场内潜在风险点，还为后续的防御策略评估和改进提供了可度量、可对比的行为基准。

\section{攻防决策与评估一体化}  
攻防演练与效果评估向来是割裂的两端，本项目则通过 LLM Agent 实现二者的无缝融合。
Agent 在执行攻防操作时实时调用内置决策模型，根据当前网络态势和历史日志动态生成下一步行动；
同时，每一次操作的上下文和结果都会反馈至评估模块，由另一个 LLM 子模型基于定量化指标进行打分并形成安全报告。
这种“决策—行为—评估”闭环可在数秒内完成一轮迭代，使得演练过程中的策略调整、漏洞修补与风险复测同步推进。
通过将攻防动作与评估分数序列化，运维团队可以直观感知策略改进的效果，驱动系统安全防护从静态配置向数据驱动不断进化。

\section{前端可视化与虚拟终端实时交互}  
项目在前端设计上同样秉持创新理念，将网络拓扑和攻防态势以可视化图表、拓扑图与时间轴形式直观呈现。
用户在浏览器中即可清晰查看各虚拟网段、主机节点及其相互连通关系。同时，内嵌的虚拟终端组件与后端实时对接，
运维人员可在同一页面内发起命令、动态调整网络参数或防火墙规则，并即时在可视化界面中观测到其影响。
该方案打通了监控与操作的最后一公里，摆脱了传统切换多窗口或终端的低效模式，大幅提升了调试效率和用户体验，
并为后续自动化运维和智能告警奠定了基础。


\chapter{项目总结与展望}
\begin{introduction}
  \item 项目总结
  \item 存在的不足与展望
\end{introduction}

\section{项目总结}
（这个总结可以放到最后写）

\section{存在的不足与展望}

\subsection{关于IPV6的支持问题}

在本次靶场设计与实施过程中，我们主要围绕传统IPv4协议体系进行网络规划与流量控制，
所有的NAT、iptables规则、服务监听与访问控制策略均基于IPv4进行构建与验证。
然而，IPv6作为下一代互联网协议，其在地址空间、点对点通信能力、自动地址配置、
安全性机制等方面具有显著优势，尤其在企业级网络部署、移动互联网、物联网等场景中
正逐渐被广泛采纳。

未在靶场中引入IPv6支持，暴露出当前系统在协议兼容性和前瞻性方面的局限。
具体而言，现有的iptables规则集并未对IPv6流量进行任何处理，宿主机及虚拟网络默认可能启用了IPv6栈
但未加以管理，理论上存在绕过现有防火墙策略的可能性。
此外，部分服务程序默认监听IPv6接口，一旦未对其明确限制，也可能导致不必要的暴露面。

从实验价值角度看，缺失IPv6网络的实验能力也限制了对某些真实世界攻击场景的还原。
例如，针对IPv6 SLAAC自动配置的钓鱼攻击、RA（Router Advertisement）欺骗等常见手段无法在当前环境中演练；同时，
也无法测试支持IPv6的恶意软件行为或入侵检测系统对IPv6流量的识别能力。

未来的靶场迭代应将IPv6纳入核心网络设计范畴，建立IPv6地址规划方案，
配置与IPv4规则并行的防火墙策略，明确虚拟资源的IPv6监听范围，
同时探索基于IPv6的攻击链建构与防御机制。只有充分考虑双栈网络环境，
靶场系统的仿真能力和安全性测试覆盖度才能更加贴近真实企业环境的演进趋势。

\subsection{关于1-day和0-day漏洞场景下EXP自动生成的问题}
在安全评估和漏洞利用流程中，自动化生成针对1-day或0-day漏洞的Exploit（EXP）一直是学界和工业界共同面临的难题。对于1-day漏洞而言，虽然漏洞细节和修补补丁公开可查，但补丁往往并未暴露完整的利用链信息，且不同环境下的内存布局、编译选项及运行时依赖千差万别，使得单纯依靠语言模型或模板化Agent生成可靠的EXP难度极高。一旦漏洞触发条件涉及复杂的程序状态或多阶段交互，这种自动化方法更容易产生失败甚至误导性的伪EXP。

对于0-day漏洞的场景，难度则更为显著。此类漏洞尚未被公开披露，缺乏任何先验的利用案例或社区讨论，Agent在训练数据中往往完全无法覆盖相应的漏洞模式。即便具备自动化静态分析或污点追踪等传统方法，结合大规模语言模型生成EXP的机制也无法弥补对未知漏洞的直观感知和对运行环境微妙差异的判断，从而难以形成可执行的利用脚本。

尽管自动化EXP生成尚未成熟，我们仍能够在评估模块中提供故障样本以供后续分析。具体而言，系统可在漏洞触发过程中捕获崩溃文件、堆栈信息及内存转储等核心数据，统一以标准化的样本格式输出。安全研究人员可以基于这些样本在调试器中重现漏洞上下文，为手动构建EXP或引入符号化调试提供必要的参考。通过持续积累不同环境和补丁版本下的故障样本库，可在一定程度上降低后续漏洞利用开发的重复成本。

在未来展望中，借助多模态神经网络与符号执行相结合的探索路线，或将为EXP自动生成提供新的可能性。但目前而言，在1-day和0-day漏洞场景下，我们更倾向于将Agent的作用聚焦于自动化样本收集与格式化，以辅助手动分析流程，并促成“样本驱动+专家复审”的混合模式，从而在保持自动化效率的同时兼顾漏洞利用的精确性与可靠性。



\chapter{部署说明和注意事项}

\begin{introduction}
    \item 开源项目地址
    \item 宿主机部署前置工作
    \item 靶场部署
    \item 攻防模块部署
    \item 前端部署
    \item 注意事项
\end{introduction}

\section{开源项目地址}

我们演示时的虚拟机的容量十分巨大，这里不直接提供地址，有复现和评审需要的可以联系任一参赛队员。

我们基于开源框架而修改的，用于靶场攻防和评测的Agent客户端代码：

\href{https://github.com/Grablocker/Pentest-Gemini.git}{https://github.com/Grablocker/Pentest-Gemini.git}

我们前端的开源地址：
\href{https://github.com/din0sauria/smart_range}{https://github.com/din0sauria/smart-range}

我们文档的开源地址：
\href{https://github.com/Grablocker/Documentation}{https://github.com/Grablocker/Documentation}





\section{宿主机部署前置工作}

为了构建一个高性能且稳定的KVM与Docker混合靶场环境，宿主机需要在硬件资源、操作系统支持和关键虚拟化组件等方面做好充分准备。以下从硬件配置、系统选择、虚拟化环境搭建和容器平台部署四个方面展开说明。

\begin{proposition}
  建议使用基于amd64架构并支持硬件虚拟化的处理器，
  例如支持Intel VT-x或AMD-V的多核CPU，至少4个物理核心，
  以保障能够并发运行多个虚拟机和容器服务。内存方面最低为16 GB，
  推荐配置32 GB或以上内存。磁盘空间方面至少保留50 GB的可用空间，
  强烈建议选用SSD，以提供更高的I/O吞吐能力，便于高速运行。
  
  操作系统方面，选择支持上述架构的主流操作即可。本项目支持OpenEuler等国产开源操作系统。
\end{proposition}


\subsection{操作系统选择与配置}

宿主机推荐安装Ubuntu Server的长期支持版本，例如Ubuntu 20.04或24.04，该系统对KVM与Docker支持良好，并拥有活跃的社区生态和丰富的文档资源。在部署前需检查并启用CPU的硬件虚拟化功能，可通过如下命令进行确认：


\begin{verbatim}
  $ lscpu | grep -E 'vmx|svm'
\end{verbatim}

若输出结果中包含“vmx”或“svm”，则说明虚拟化功能已被CPU支持。如未显示，则需进入BIOS或UEFI设置手动开启虚拟化选项。

\subsection{KVM及其管理工具安装}

KVM是基于Linux内核的虚拟化机制，可将宿主机作为裸机虚拟化管理器运行多个虚拟机。Libvirt作为其管理工具集，提供统一的虚拟机配置与管理接口，支持命令行与图形化管理方式。Virt-Manager作为图形前端，便于对虚拟机状态进行可视化查看与控制。安装步骤如下：

安装KVM及相关软件包：

\begin{verbatim}
  $ sudo apt update
  $ sudo apt -y install bridge-utils cpu-checker libvirt-clients 
  $ sudo apt -y install libvirt-daemon qemu qemu-kvm virt-manager
\end{verbatim}

添加当前用户至libvirt与kvm用户组以获得管理权限：

\begin{verbatim}
  $ sudo usermod -aG libvirt $USER
  $ sudo usermod -aG kvm $USER
\end{verbatim}

验证KVM模块是否加载成功：

\begin{verbatim}
  $ kvm-ok
\end{verbatim}

若输出显示/dev/kvm存在并支持加速，即说明KVM功能正常。

启动并设定libvirtd服务为开机自启：

\begin{verbatim}
  $ sudo systemctl enable --now libvirtd
\end{verbatim}

Libvirt可用于创建虚拟网络、自动配置网桥与DHCP服务，并设置iptables规则，为后续部署多网段靶场提供良好的支持基础。

\subsection{Docker及Compose平台安装}

Docker平台将在靶场中承担Web服务、邮件系统、数据库与监控栈等容器化服务的部署任务，Docker Compose用于协调多容器服务的构建与编排。安装步骤如下：

安装基础依赖：

\begin{verbatim}
  $ sudo apt update
  $ sudo apt install ca-certificates curl gnupg
\end{verbatim}

添加Docker官方GPG密钥：

\begin{verbatim}
  $ sudo install -m 0755 -d /etc/apt/keyrings
  $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg
  $ sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
\end{verbatim}

配置Docker软件源：

\begin{verbatim}
  $ echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg]
  https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable"
  | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
\end{verbatim}

安装Docker及其组件：

\begin{verbatim}
  $ sudo apt update
$ sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
\end{verbatim}

添加用户至docker用户组：

\begin{verbatim}
  $ sudo usermod -aG docker $USER
\end{verbatim}

完成安装后，可通过运行测试容器确认安装状态：

\begin{verbatim}
  $ docker run hello-world
\end{verbatim}

若成功输出欢迎信息，说明Docker平台已正确配置完成。


\section{靶场部署}

\subsection{跳板机}

跳板机是靶场接受外网访问的桥梁，也是唯一一个依赖完全手动配置的靶场组件。根据文档描述，我们使用了openVPN作为跳板机的网络设施。

openVPN的原项目地址：
\href{https://github.com/OpenVPN/openvpn}{https://github.com/OpenVPN/openvpn}

这里我们推荐下载器配置，这个下载器是Github上的开发人员整理的一个兼容性强的下载脚本，可以一键启用。这也是我们的配置方式；
项目地址
\href{https://github.com/Nyr/openvpn-install/}{https://github.com/Nyr/openvpn-install/}



\subsection{靶场内网和虚拟主机}

在靶场内网和虚拟主机的部署中，VM是用户根据自行需求和复现条件打包设计的，用户可以根据需要选择已有的漏洞镜像或自行构建。
而docker可以用来充当轻量化的服务和构建单元，当然也可以使用VulnHub等镜像网站自行搭建和获取具有特定漏洞的Docker镜像，并与VM虚拟机任意搭配网段；
我们的靶场可以做到VM和docker的统一管理和自由部署。

打包好虚拟机的VM镜像之后，提交靶场网络拓扑结构的表单，使用Agent自动构建靶场网络拓扑结构；

如果不需要特意部署带有漏洞的Docker容器，那么Docker的拉取和运行可以通过Agent自动完成。
Agent会自动生成对应的Docker容器，并配置好网络桥接和iptables防火墙规则。



\section{攻防模块部署}

如文档中介绍所示，我们的攻击Agent部署在一个Kali Linux虚拟机中。
在Kali Linux中，我们将上述提到的Agent集成到了攻击机中，并使用npm link集成了呼出命令,无需额外进行配置，直接终端使用gemini命令即可呼出。


\section{前端部署}

首先，通过 Git 克隆项目到本地工作目录：
\begin{verbatim}
  git clone https://github.com/din0sauria/smart_range.git
  cd smart_range
\end{verbatim}

推荐使用 VSCode 作为主要编辑器，并安装 Volar 插件来替代 Vetur，以获得对 Vue 3 和 TypeScript 更精准的语法提示与类型检查。

进入项目根目录后，执行以下命令安装所有前端依赖：
\begin{verbatim}
  npm install
\end{verbatim}

在开发过程中，可以使用热重载功能快速预览修改效果：
\begin{verbatim}
  npm run dev
\end{verbatim}

完成开发并准备发布时，运行以下命令对项目进行构建和压缩，生成面向生产环境的静态资源：
\begin{verbatim}
  npm run build
\end{verbatim}

若需启用页面中的虚拟终端功能，请在独立终端中启动后端服务：
\begin{verbatim}
  python testvtcmd.py
\end{verbatim}





\section{注意事项}

\subsection{Windows 机器部署要求}
在靶场环境中引入 Windows 虚拟机时，必须确保操作系统内已安装并启用了 VirtIO 驱动，
以实现网络、存储与串口等虚拟化设备的高效交互。若部署前未在 ISO 或映像中集成 VirtIO 驱动程序，
Windows 安装过程将无法识别底层虚拟磁盘及网络接口，此时应在安装选项中启用 SATA 控制器以保障磁盘可见性，
但这会带来性能与灵活性上的折中。为避免后续因驱动缺失而导致的网络中断或无法挂载虚拟盘，
建议在创建 Windows 模板时进行一次性驱动注入，并在首次引导后验证网络连接与磁盘读写性能。
这样既可最大程度地发挥虚拟化平台的吞吐能力，又能确保后续自动化管理与快照操作的稳定性。

\subsection{Vue 开发环境配置}
在构建基于 Vue 的前端项目时，推荐在 VSCode 中使用 Volar 作为主要语言服务插件，
并在此基础上禁用旧版本的 Vetur 扩展以避免误判与性能冲突。首先，确保在扩展市场中安装最新版本的 Volar，
并在工作区设置中启用 Take Over Mode，使其能够接管对文件的模板、脚本和样式部分的语法提示和错误检查。
接着，进入 VSCode 的扩展管理界面，将已安装的 Vetur 扩展标记为禁用或直接卸载；
这一步可防止两套诊断服务同时运行导致的重复报错、自动补全迟滞以及类型推断不一致等问题。
在工作区配置文件中推荐强化 Volar 的支持力度并关闭 Vetur 相关功能。


% \chapter{ElegantBook 写作示例}

% \begin{introduction}
%   \item 积分定义~\ref{def:int}
%   \item Fubini 定理~\ref{thm:fubi}
%   \item 最优性原理~\ref{pro:max}
%   \item 柯西列性质~\ref{property:cauchy}
%   \item 韦达定理
% \end{introduction}

% \section{Lebesgue 积分}
% 在前面各章做了必要的准备后，本章开始介绍新的积分。在 Lebesgue 测度理论的基础上建立了 Lebesgue 积分，其被积函数和积分域更一般，可以对有界函数和无界函数统一处理。正是由于 Lebesgue 积分的这些特点，使得 Lebesgue 积分比 Riemann 积分具有在更一般条件下的极限定理和累次积分交换积分顺序的定理，这使得 Lebesgue 积分不仅在理论上更完善，而且在计算上更灵活有效。

% Lebesgue 积分有几种不同的定义方式。我们将采用逐步定义非负简单函数，非负可测函数和一般可测函数积分的方式。

% 由于现代数学的许多分支如概率论、泛函分析、调和分析等常常用到一般空间上的测度与积分理论，在本章最后一节将介绍一般的测度空间上的积分。

% \subsection{积分的定义}

% 我们将通过三个步骤定义可测函数的积分。首先定义非负简单函数的积分。以下设 $E$ 是 $\mathcal{R}^n$ 中的可测集。

% \begin{definition}[可积性] \label{def:int} 
% 设 $ f(x)=\sum\limits_{i=1}^{k} a_i \chi_{A_i}(x)$ 是 $E$ 上的\textbf{非负简单函数}，中文其中 $\{A_1,A_2,\ldots,A_k\}$ 是 $E$ 上的一个可测分割，$a_1,a_2,\ldots,a_k$ 是非负实数。定义 $f$ 在 $E$ 上的积分为 $\int_{a}^b f(x)$
% \begin{equation}
%    \label{inter}
%    \int_{E} f dx = \sum_{i=1}^k a_i m(A_i) \pi \alpha\beta\sigma\gamma\nu\xi\epsilon\varepsilon. \oint_{a}^b\ointop_{a}^b\prod_{i=1}^n
% \end{equation}
% 一般情况下 $0 \leq \int_{E} f dx \leq \infty$。若 $\int_{E} f dx < \infty$，则称 $f$ 在 $E$ 上可积。
% \end{definition}

% 一个自然的问题是，Lebesgue 积分与我们所熟悉的 Riemann 积分有什么联系和区别？在 4.4 在我们将详细讨论 Riemann 积分与 Lebesgue 积分的关系。这里只看一个简单的例子。设 $D(x)$ 是区间 $[0,1]$ 上的 Dirichlet 函数。即 $D(x)=\chi_{Q_0}(x)$，其中 $Q_0$ 表示 $[0,1]$ 中的有理数的全体。根据非负简单函数积分的定义，$D(x)$ 在 $[0,1]$ 上的 Lebesgue 积分为
% \begin{equation}
%    \label{inter2}
%    \int_0^1 D(x)dx = \int_0^1 \chi_{Q_0} (x) dx = m(Q_0) = 0
% \end{equation}
% 即 $D(x)$ 在 $[0,1]$ 上是 Lebesgue 可积的并且积分值为零。但 $D(x)$ 在 $[0,1]$ 上不是 Riemann 可积的。


% 有界变差函数是与单调函数有密切联系的一类函数。有界变差函数可以表示为两个单调递增函数之差。与单调函数一样，有界变差函数几乎处处可导。与单调函数不同，有界变差函数类对线性运算是封闭的，它们构成一线空间。练习题 \ref{exer:43} 是一个性质的证明。

% \begin{exercise}\label{exer:43}
% 设 $f \notin\in L(\mathcal{R}^1)$，$g$ 是 $\mathcal{R}^1$ 上的有界可测函数。证明函数
% \begin{equation}
%    \label{ex:1}
%    I(t) = \int_{\mathcal{R}^1} f(x+t)g(x)dx \quad t \in \mathcal{R}^1
% \end{equation}
% 是 $\mathcal{R}^1$ 上的连续函数。 
% \end{exercise}

% \begin{solution}
% 即 $D(x)$ 在 $[0,1]$ 上是 Lebesgue 可积的并且积分值为零。但 $D(x)$ 在 $[0,1]$ 上不是 Riemann 可积的。
% \end{solution}

% \begin{proof}
% 即 $D(x)$ 在 $[0,1]$ 上是 Lebesgue 可积的并且积分值为零。但 $D(x)$ 在 $[0,1]$ 上不是 Riemann 可积的。
% \end{proof}

% \begin{theorem}[Fubini 定理] \label{thm:fubi} 
% （1）若 $f(x,y)$ 是 $\mathcal{R}^p\times\mathcal{R}^q$ 上的非负可测函数，则对几乎处处的 $x\in \mathcal{R}^p$，$f(x,y)$ 作为 $y$ 的函数是 $\mathcal{R}^q$ 上的非负可测函数，$g(x)=\int_{\mathcal{R}^q}f(x,y) dy$ 是 $\mathcal{R}^p$ 上的非负可测函数。并且
% \begin{equation}
%    \label{eq:461}
%    \int_{\mathcal{R}^p\times\mathcal{R}^q} f(x,y) dxdy=\int_{\mathcal{R}^p}\left(\int_{\mathcal{R}^q}f(x,y)dy\right)dx.
% \end{equation}

% （2）若 $f(x,y)$ 是 $\mathcal{R}^p\times\mathcal{R}^q$ 上的可积函数，则对几乎处处的 $x\in\mathcal{R}^p$，$f(x,y)$ 作为 $y$ 的函数是 $\mathcal{R}^q$ 上的可积函数，并且 $g(x)=\int_{\mathcal{R}^q}f(x,y) dy$ 是 $\mathcal{R}^p$ 上的可积函数。而且~\ref{eq:461} 成立。
% \end{theorem}

% \ref{thm:fubi}

% \begin{note}
% 在本模板中，引理（lemma），推论（corollary）的样式和定理~\ref{thm:fubi} 的样式一致，包括颜色，仅仅只有计数器的设置不一样。
% \end{note}

% 我们说一个实变或者复变量的实值或者复值函数是在区间上平方可积的，如果其绝对值的平方在该区间上的积分是有限的。所有在勒贝格积分意义下平方可积的可测函数构成一个希尔伯特空间，也就是所谓的 $L^2$ 空间，几乎处处相等的函数归为同一等价类。形式上，$L^2$ 是平方可积函数的空间和几乎处处为 0 的函数空间的商空间。

% \begin{proposition}[最优性原理] \label{pro:max}
% 如果 $u^*$ 在 $[s,T]$ 上为最优解，则 $u^*$ 在 $[s, T]$ 任意子区间都是最优解，假设区间为 $[t_0, t_1]$ 的最优解为 $u^*$ ，则 $u(t_0)=u^{*}(t_0)$，即初始条件必须还是在 $u^*$ 上。
% \end{proposition}

% 我们知道最小二乘法可以用来处理一组数据，可以从一组测定的数据中寻求变量之间的依赖关系，这种函数关系称为经验公式。本课题将介绍最小二乘法的精确定义及如何寻求点与点之间近似成线性关系时的经验公式。假定实验测得变量之间的 $n$ 个数据，则在平面上，可以得到 $n$ 个点，这种图形称为 “散点图”，从图中可以粗略看出这些点大致散落在某直线近旁, 我们认为其近似为一线性函数，下面介绍求解步骤。

% \begin{figure}[htbp]
%   \centering
%   \includegraphics[width=0.6\textwidth]{scatter.jpg}
%   \caption{散点图示例 $\hat{y}=a+bx$ \label{fig:scatter}}
% \end{figure}

% 以最简单的一元线性模型来解释最小二乘法。什么是一元线性模型呢？监督学习中，如果预测的变量是离散的，我们称其为分类（如决策树，支持向量机等），如果预测的变量是连续的，我们称其为回归。回归分析中，如果只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。对于二维空间线性是一条直线；对于三维空间线性是一个平面，对于多维空间线性是一个超平面。

% \begin{property}\label{property:cauchy}
% 柯西列的性质
% \begin{enumerate}
% \item $\{x_k\}$ 是柯西列，则其子列 $\{x_k^i\}$ 也是柯西列。
% \item $x_k\in \mathcal{R}^n$，$\rho(x,y)$ 是欧几里得空间，则柯西列收敛，$(\mathcal{R}^n,\rho)$ 空间是完备的。
% \end{enumerate}
% \end{property}

% \begin{conclusion}
% 回归分析（regression analysis) 是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。运用十分广泛，回归分析按照涉及的变量的多少，分为一元回归和多元回归分析；按照因变量的多少，可分为简单回归分析和多重回归分析；按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析。
% \end{conclusion}

% \begin{problemset}
% \item 设 $A$ 为数域 $K$ 上的 $n$ 级矩阵。证明：如果 $K^n$ 中任意非零列向量都是 $A$ 的特征向量，则 $A$ 一定是数量矩阵。
% \item 证明：不为零矩阵的幂零矩阵不能对角化。
% \item 设 $A = (a_{ij})$ 是数域 $K$ 上的一个 $n$ 级上三角矩阵，证明：如果 $a_{11} = a_{22} = \cdots = a_{nn}$，并且至少有一个 $a_{kl} \not = 0 (k < l)$，则 $A$ 一定不能对角化。
% \end{problemset}

% \chapter{常见问题集}

% 我们根据用户社区反馈整理了下面一些常见的问题，用户在遇到问题时，应当首先查阅本手册和本部分的常见的问题。

% \begin{enumerate}[itemsep=1.5ex]
%   \item \question{有没有办法章节用“第一章，第一节，（一）”这种？}
%     见前文介绍，可以使用 \lstinline{scheme=chinese} 设置。
%   \item \question{大佬，我想把正文字体改为亮色，背景色改为黑灰色。}
%     页面颜色可以使用 \lstinline{\pagecolor} 命令设置，文本命令可以参考\href{https://tex.stackexchange.com/questions/278544/xcolor-what-is-the-equivalent-of-default-text-color}{这里}进行设置。
%   \item \question{\lstinline[breaklines]{Package ctex Error: CTeX fontset 'Mac' is unavailable.}}
%     在 Mac 系统下，中文编译请使用 \hologo{XeLaTeX}。
%   \item \question{\lstinline{! LaTeX Error: Unknown option 'scheme=plain' for package 'ctex'.}}
%     你用的 C\TeX{} 套装吧？这个里面的 \lstinline{ctex} 宏包已经是已经是 10 年前的了，与本模板使用的 \lstinline{ctex} 宏集有很大区别。不建议 C\TeX{} 套装了，请卸载并安装 \TeX{} Live 2022。
%   \item \question{我该使用什么版本？}
%     请务必使用\href{https://github.com/ElegantLaTeX/ElegantBook/releases}{最新正式发行版}，发行版间不定期可能会有更新（修复 bug 或者改进之类），如果你在使用过程中没有遇到问题，不需要每次更新\href{https://github.com/ElegantLaTeX/ElegantBook/archive/master.zip}{最新版}，但是在发行版更新之后，请尽可能使用最新版（发行版）！最新发行版可以在 GitHub 或者 \TeX{} Live 2021 内获取。
%   \item \question{我该使用什么编辑器？}
%     你可以使用 \TeX{} Live 2021 自带的编辑器 \TeX{}works 或者使用 \TeX{}studio，\TeX works 的自动补全，你可以参考我们的总结 \href{https://github.com/EthanDeng/texworks-autocomplete}{\TeX works 自动补全}。推荐使用 \TeX{} Live 2021 + \TeX{}studio。我自己用 VS Code 和 Sublime Text，相关的配置说明，请参考 \href{https://github.com/EthanDeng/vscode-latex}{\LaTeX{} 编译环境配置：Visual Studio Code 配置简介} 和 \href{https://github.com/EthanDeng/sublime-text-latex}{Sublime Text 搭建 \LaTeX{} 编写环境}。
%   \item \question{您好，我们想用您的 ElegantBook 模板写一本书。关于机器学习的教材，希望获得您的授权，谢谢您的宝贵时间。}
%     模板的使用修改都是自由的，你们声明模板来源以及模板地址（GitHub 地址）即可，其他未尽事宜按照开源协议 LPPL-1.3c。做好之后，如果方便的话，可以给我们一个链接，我把你们的教材放在 Elegant\LaTeX{} 用户作品集里。
%   \item \question{请问交叉引用是什么？}
%     本群和本模板适合有一定 \LaTeX{} 基础的用户使用，新手请先学习 \LaTeX{} 的基础，理解各种概念，否则你将寸步难行。
%   \item \question{代码高亮环境能用其他语言吗？}
%     可以的，ElegantBook 模板用的是 \lstinline{listings} 宏包，你可以在环境（\lstinline{lstlisting}）之后加上语言（比如 Python 使用 \lstinline{language=Python} 选项），全局语言修改请使用 \lstinline{lsset} 命令，更多信息请参考宏包文档。
%   \item \question{群主，什么时候出 Beamer 的模板（主题），ElegantSlide 或者 ElegantBeamer？}
%     由于 Beamer 中有一个很优秀的主题 \href{https://github.com/matze/mtheme}{Metropolis}。后续确定不会再出任何主题/模板，请大家根据需要修改已有主题。
% \end{enumerate}

% \chapter{版本更新历史}

% 根据用户的反馈，我们不断修正和完善模板。由于 3.00 之前版本与现在版本差异非常大，在此不列出 3.00 之前的更新内容。


% \datechange{2022/04/09}{版本 4.3 正式发布。}

% \begin{change}
%   \item 放弃 newtx 系列宏包的设置，改用 TeX Gyre Terms，并设置其他字体；
%   \item 修改定理类环境内部字体设置，修复环境内部中文无法加粗问题；
%   \item 增加定理类环境的计数器选项 \lstinline{thmcnt}，可选 \lstinline{chapter} 和 \lstinline{section}；
%   \item 增加 \lstinline{bibend} 选项，可选 \lstinline{bibend=biber}（默认）和 \lstinline{bibend=bibtex}。
% \end{change}



% \datechange{2022/03/08}{版本 4.2 正式发布。}

% \begin{change}
%   \item 对于 newtx 系列宏包更新导致的字体 bug 的修复；
%   \item 修缮目录格式，为了达到这个目的，重新改写 \lstinline{\chaptername} 的重定义语句；
%   \item 增加日语 \lstinline{lang=jp} 设定。
%   \item 这个版本为一个临时性版本，在 \TeX Live 2022 发布之后，将尽快发布 4.3 版本，由于对于中文的改动比较大，可能会出现预期之外的 bug，有问题可以在 QQ 群或者 Github 反馈。
% \end{change}


% \datechange{2021/05/02}{版本 4.1 正式发布。}

% \begin{change}
%   \item \textbf{重要改动}：由原先的 \hologo{BibTeX} 改为 biblatex 编译方式（后端为 \lstinline{biber}），请注意两者之间的差异；
%   \item \textbf{重要改进}：修改对于定理写法兼容方式，提高数学公式代码的兼容性；
%   \item 页面设置改动，默认页面更宽；方便书写和阅读；
%   \item 支持目录文字以及页码跳转；
%   \item 不再维护 \hologo{pdfLaTeX} 中文支持方式，请务必使用 \hologo{XeLaTeX} 编译中文文稿。
%   \item 增加多个语言选项，法语 \lstinline{lang=fr}、荷兰语 \lstinline{lang=nl}、匈牙利语 \lstinline{lang=hu}、西班牙语 \lstinline{lang=es}、蒙古语 \lstinline{lang=mn} 等。
% \end{change}


% \datechange{2020/04/12}{版本 3.11 正式发布，\textcolor{red}{此版本为 3.x 最后版本。}}

% \begin{change}
%   \item \textbf{重要修正}：修复因为 \lstinline{gbt7714} 宏包更新导致的 \lstinline{natbib option clash} 错误；
%   \item 由于 \lstinline{pgfornament} 宏包未被 \TeX{} Live 2020 收录，因此删除 base 相关的内容；
%   \item 修复部分环境的空格问题；
%   \item 增加了意大利语言选项 \lstinline{lang=it}。
% \end{change}


% \datechange{2020/02/10}{版本 3.10 正式发布}

% \begin{change}
%   \item 增加数学字体选项 \lstinline{math}，可选项为 \lstinline{newtx} 和 \lstinline{cm}。\\
%   \textbf{重要提示}：原先通过 \lstinline{newtxmath} 宏包设置的数学字体改为 \LaTeX{} 默认数学字体，如果需要保持原来的字体，需要显式声明数学字体（\lstinline{math=newtx}）；
%   \item 新增中文字体选项 \lstinline{chinesefont}，可选项为 \lstinline{ctexfont}、\lstinline{founder} 和 \lstinline{nofont}。
%   \item 将封面作者信息设置为可选，并且增加自定义信息命令 \lstinline{\bioinfo}；
%   \item 在说明文档中增加版本历史，新增 \lstinline{\datechange} 命令和 \lstinline{change} 环境；
%   \item 增加汉化章节选项 \lstinline{scheme}，可选项为汉化 \lstinline{chinese}；
%   \item 由于 \lstinline{\lvert} 问题已经修复，重新调整 \lstinline{ctex} 宏包和 \lstinline{amsmath} 宏包位置。
%   \item 修改页眉设置，去除了 \lstinline{\lastpage} 以避免 page anchor 问题，加入 \lstinline{\frontmatter}。
%   \item 修改参考文献选项 \lstinline{cite}，可选项为数字 \lstinline{numbers}、 作者-年份 \lstinline{authoryear} 以及上标 \lstinline{super}。
%   \item 新增参考文献样式选项 \lstinline{bibstyle}，并将英文模式下参考文献样式 \lstinline{apalike} 设置为默认值，中文仍然使用 \lstinline{gbt7714} 宏包设置。
% \end{change}

% \datechange{2019/08/18}{版本 3.09 正式发布}

% \begin{change}
%   \item \lstinline{\elegantpar} 存在 bug，删除 \lstinline{\elegantpar} 命令，建议用户改用 \lstinline{\marginnote} 和 \lstinline{\marginpar} 旁注命令。
%   \item 积分操作符统一更改为 \lstinline{esint} 宏包设置；
%   \item 新增目录选项 \lstinline{toc}，可选项为单栏 \lstinline{onecol} 和双栏 \lstinline{twocol}；
%   \item 手动增加参考文献选项 \lstinline{cite}，可选项为上标形式 \lstinline{super}；
%   \item 修正章节习题（\lstinline{problemset}）环境。
% \end{change}

% \datechange{2019/05/28}{版本 3.08 正式发布}

% \begin{change}
%   \item 修复 \lstinline{\part} 命令。
%   \item 引入 Note 模板中的 \lstinline{pad} 选项 \lstinline{device=pad}。
%   \item 数学字体加入 \lstinline{mtpro2} 可选项 \lstinline{math=mtpro2}，使用免费的 \lstinline{lite} 子集。
%   \item 将参考文献默认显示方式 \lstinline{authoyear} 改为 \lstinline{numbers}。
%   \item 引入旁注命令 \lstinline{\marginpar}（测试）。
%   \item 新增章节摘要环境 \lstinline{introduction}。
%   \item 新增章节习题环境 \lstinline{problemset}。
%   \item 将 \lstinline{\equote} 重命名为 \lstinline{\extrainfo}。
%   \item 完善说明文档，增加致谢部分。
% \end{change}

% \datechange{2019/04/15}{版本 3.07 正式发布}

% \begin{change}
%   \item 删除中英文自定义字体总设置。
%   \item 新增颜色主题，并将原绿色默认主题设置为蓝色 \lstinline{color=blue}。
%   \item 引入隐藏装饰图案选项 \lstinline{base}，可选项有显示 \lstinline{show} 和隐藏 \lstinline{hide}。
%   \item 新增定理模式 \lstinline{mode}，可选项有简单模式 \lstinline{simple} 和炫彩模式 \lstinline{fancy}。
%   \item 新增隐藏证明、答案等环境的选项 \lstinline{result=noanswer}。
% \end{change}

% \datechange{2019/02/25}{版本 3.06 正式发布}

% \begin{change}
%   \item 删除水印。
%   \item 新封面，新装饰图案。
%   \item 添加引言使用说明。
%   \item 修复双面 \lstinline{twoside}。
%   \item 美化列表环境。
%   \item 增加 \lstinline{\subsubsection} 的设置。
%   \item 将模板拆分成中英文语言模式。
%   \item 使用 \lstinline{lstlisting} 添加代码高亮。
%   \item 增加定理类环境使用说明。
% \end{change}

% \datechange{2019/01/22}{版本 3.05 正式发布}

% \begin{change}
%   \item 添加 \lstinline{xeCJK} 宏包中文支持方案。
%   \item 修复模板之前对 Ti\textit{k}Z 单位的改动。
%   \item 更新 logo 图。
% \end{change}

% \datechange{2019/01/15}{版本 3.04 正式发布}

% \begin{change}
%   \item 格式化模板代码。
%   \item 增加 \lstinline{\equote} 命令。
%   \item 修改 \lstinline{\date}。
% \end{change}

% \datechange{2019/01/08}{版本 3.03 正式发布}

% \begin{change}
%   \item 修复附录章节显示问题。
%   \item 小幅优化封面代码。
% \end{change}

% \datechange{2018/12/31}{版本 3.02 正式发布}

% \begin{change}
%   \item 修复名字系列命令自定义格式时出现的空格问题，比如 \lstinline{\listfigurename}。
%   \item 英文定理类名字改为中文名。
%   \item 英文结构名改为中文。
% \end{change}

% \datechange{2018/12/16}{版本 3.01 正式发布}

% \begin{change}
%   \item 调整 \lstinline{ctex} 宏包。
%   \item 说明文档增加更新内容。
% \end{change}

% \datechange{2018/12/06}{版本 3.00 正式发布}

% \begin{change}
%   \item 删除 \lstinline{mathpazo} 数学字体选项。
%   \item 添加邮箱命令 \lstinline{\mailto}。
%   \item 修改英文字体为 \lstinline{newtx} 系列，另外大型操作符号维持 cm 字体。
%   \item 中文字体改用 \lstinline{ctex} 宏包自动设置。
%   \item 删除 \lstinline{xeCJK} 字体设置，原因是不同系统字体不方便统一。
%   \item 定理换用 \lstinline{tcolobox} 宏包定义，并基本维持原有的定理样式，优化显示效果，支持跨页；定理类名字重命名，如 etheorem 改为 theorem 等等。
%   \item 删去自定义的缩进命令 \lstinline{\Eindent}。
%   \item 添加参考文献宏包 \lstinline{natbib}。
%   \item 颜色名字重命名。
% \end{change}

% \nocite{*}
% \printbibliography[heading=bibintoc, title=\ebibname]
% \appendix

% \chapter{基本数学工具}


% 本附录包括了计量经济学中用到的一些基本数学，我们扼要论述了求和算子的各种性质，研究了线性和某些非线性方程的性质，并复习了比例和百分数。我们还介绍了一些在应用计量经济学中常见的特殊函数，包括二次函数和自然对数，前 4 节只要求基本的代数技巧，第 5 节则对微分学进行了简要回顾；虽然要理解本书的大部分内容，微积分并非必需，但在一些章末附录和第 3 篇某些高深专题中，我们还是用到了微积分。

% \section{求和算子与描述统计量}

% \textbf{求和算子} 是用以表达多个数求和运算的一个缩略符号，它在统计学和计量经济学分析中扮演着重要作用。如果 $\{x_i: i=1, 2, \ldots, n\}$ 表示 $n$ 个数的一个序列，那么我们就把这 $n$ 个数的和写为：

% \begin{equation}
% \sum_{i=1}^n x_i \equiv x_1 + x_2 +\cdots + x_n
% \end{equation}



\end{document}
